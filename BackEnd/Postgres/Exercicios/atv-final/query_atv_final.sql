-- ### Desafios com Triggers e Trigger Functions ###

--TABELAS UTILIZADAS: DEPARTAMENTO E EMPREGADO
	--SELECT * FROM DEPARTAMENTO
	--SELECT * FROM EMPREGADO

-- 1. Auditoria de Alterações:
--    - Crie um trigger que registre todas as inserções, atualizações e exclusões na 
-- 	tabela `empregado` em uma tabela de auditoria chamada `auditoria_empregado`. 
-- 	Esta tabela deve armazenar a ação realizada (`INSERT`, `UPDATE`, `DELETE`), 
-- 	a data/hora da ação e a matrícula do empregado afetado.

--SELECT * FROM AUDITORIA_EMPREGADO
--DROP TABLE AUDITORIA_EMPREGADO
CREATE TABLE IF NOT EXISTS AUDITORIA_EMPREGADO (
    ID SERIAL,
    OPERACAO VARCHAR(10) NOT NULL,
    DATA_HORA TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    MAT_EMPREGADO INT,
	--CHAVE PRIMARIA
	CONSTRAINT AUDITORIA_EMP_ID_PK PRIMARY KEY (ID)	
);

--SELECT * FROM AUDITORIA_EMPREGADO
INSERT INTO EMPREGADO (NOME_EMPREGADO,DATA_DE_NASCIMENTO, SALARIO, NUM_DEPTO) 
VALUES
	('Fabricio Fragoso', '1993-02-04', 10000, 6)

--SELECT * FROM AUDITORIA_EMPREGADO
UPDATE EMPREGADO SET 
	NOME_EMPREGADO = 'Felipe Fragoso', DATA_DE_NASCIMENTO = '1986-12-16' 
WHERE MATRICULA = 69

--SELECT * FROM AUDITORIA_EMPREGADO
DELETE FROM EMPREGADO WHERE MATRICULA = 69

--TRIGGER PARA O INSERT DE EMPREGADO
CREATE TRIGGER TRIGGER_EMPREGADO_INSERT
AFTER INSERT ON EMPREGADO
FOR EACH ROW
EXECUTE FUNCTION T_EMP_INSERT_FN();

--FUNÇÃO PARA O TRIGGER DE INSERT DE EMPREGADO
CREATE OR REPLACE FUNCTION T_EMP_INSERT_FN()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO AUDITORIA_EMPREGADO (OPERACAO, DATA_HORA, MAT_EMPREGADO)
    VALUES ('INSERT', CURRENT_TIMESTAMP, NEW.MATRICULA);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

--TRIGGER PARA O UPDATE DE EMPREGADO
CREATE TRIGGER TRIGGER_EMPREGADO_UPDATE
AFTER UPDATE ON EMPREGADO
FOR EACH ROW
EXECUTE FUNCTION T_EMP_UPDATE_FN();

--FUNÇÃO PARA O TRIGGER DE UPDATE DE EMPREGADO
CREATE OR REPLACE FUNCTION T_EMP_UPDATE_FN()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO AUDITORIA_EMPREGADO (OPERACAO, DATA_HORA, MAT_EMPREGADO)
    VALUES ('UPDATE', CURRENT_TIMESTAMP, NEW.MATRICULA);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

--TRIGGER PARA O DELETE DE EMPREGADO
CREATE TRIGGER TRIGGER_EMPREGADO_DELETE
AFTER DELETE ON EMPREGADO
FOR EACH ROW
EXECUTE FUNCTION T_EMP_DELETE_FN();

--FUNÇÃO PARA O TRIGGER DE DELETE DE EMPREGADO
CREATE OR REPLACE FUNCTION T_EMP_DELETE_FN()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO AUDITORIA_EMPREGADO (OPERACAO, DATA_HORA, MAT_EMPREGADO)
    VALUES ('DELETE', CURRENT_TIMESTAMP, OLD.MATRICULA);
    RETURN OLD;
END;
$$ LANGUAGE plpgsql;

--                            ### END 1º QUESTÃO ###

-- 2. Controle de Salário Máximo:
--    - Crie um trigger que impeça que um empregado receba um aumento de salário que 
-- 	exceda 20% do seu salário atual. Se um aumento maior que 20% for tentado, o 
-- 	trigger deve lançar uma exceção.

--TRIGGER PARA O UPDATE DE SALARIO DO EMPREGADO
CREATE TRIGGER TRIGGER_SEM_AUMENTO
BEFORE UPDATE ON EMPREGADO
FOR EACH ROW
EXECUTE FUNCTION AUMENTO_SALARIAL_20_FN();

--FUNÇÃO PARA O TRIGGER PARA O AUMENTO DE SALARIO DO EMPRESARIO
CREATE OR REPLACE FUNCTION AUMENTO_SALARIAL_20_FN()
RETURNS TRIGGER AS $$
BEGIN
	IF (NEW.SALARIO > OLD.SALARIO) THEN
	    IF (NEW.SALARIO > OLD.SALARIO * 1.2) THEN
	        RAISE EXCEPTION 'Aumento de salário maior que 20%% não é permitido';
	    END IF;
	END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

--SELECT NOME_EMPREGADO, SALARIO FROM EMPREGADO WHERE MATRICULA = 33
UPDATE EMPREGADO SET SALARIO = SALARIO * 1.3 WHERE MATRICULA = 33;

--SELECT NOME_EMPREGADO, SALARIO FROM EMPREGADO WHERE MATRICULA = 33
UPDATE EMPREGADO SET SALARIO = SALARIO * 1.1 WHERE MATRICULA = 33;

--                            ### END 2º QUESTÃO ###

-- 3. Histórico de Salário:
--    - Crie uma tabela `historico_salario` que armazene o histórico de salários 
-- 	dos empregados. Crie um trigger que insira um registro nesta tabela sempre 
-- 	que o salário de um empregado for atualizado.

--SELECT * FROM HISTORICO_SALARIAL
--DROP TABLE HISTORICO_SALARIAL
CREATE TABLE IF NOT EXISTS HISTORICO_SALARIAL (
    ID SERIAL,
    MAT_EMPREGADO INT NOT NULL,
	NOME_EMPREGADO VARCHAR(100) NOT NULL,
    SALARIO_ANTIGO DECIMAL(10,2) NOT NULL,
    SALARIO_NOVO DECIMAL(10,2) NOT NULL,
    DATA_HORA TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
	--CHAVE PRIMARIA
	CONSTRAINT HIST_SAL_ID_PK PRIMARY KEY (ID),
	--CHAVE ESTRANGEIRA
	CONSTRAINT HIST_SAL_MAT_FK FOREIGN KEY (MAT_EMPREGADO)
    REFERENCES EMPREGADO (MATRICULA)	
);

--SELECT * FROM HISTORICO_SALARIAL
-- OBS: VALORES ABAIXO DE 20% POR CAUSA DA 2º QUESTÃO 
UPDATE EMPREGADO SET SALARIO = SALARIO * 1.1 WHERE MATRICULA = 25;

--TRIGGER DE UPDATE DA TABELA HISTORICO_SALARIAL
CREATE TRIGGER TRIGGER_HISTORICO_SALARIAL
AFTER UPDATE OF SALARIO ON EMPREGADO
FOR EACH ROW
EXECUTE FUNCTION HISTORICO_SALARIAL_INSERT_FN();

--FUNÇÃO PARA O TRIGGER PARA INSERIR VALORES NA TABELA HISTORICO_SALARIAL
CREATE OR REPLACE FUNCTION HISTORICO_SALARIAL_INSERT_FN()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.SALARIO <> OLD.SALARIO THEN
        INSERT INTO HISTORICO_SALARIAL (MAT_EMPREGADO, NOME_EMPREGADO, 
										SALARIO_ANTIGO, SALARIO_NOVO, DATA_HORA)
        VALUES (NEW.MATRICULA, NEW.NOME_EMPREGADO, OLD.SALARIO, NEW.SALARIO, 
				CURRENT_TIMESTAMP);
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

--                            ### END 3º QUESTÃO ###

-- 4. Atualização Automática de Idade:
--    - Crie um trigger que atualize automaticamente a idade dos empregados todos 
-- 	os anos, com base em sua data de nascimento armazenada na tabela `empregado`.

-- ADD A COLUNA IDADE A TABELA EMPREGADO
ALTER TABLE EMPREGADO ADD COLUMN IDADE INT;

--UPDATE DE TODAS AS IDADES EM RELAÇÃO A DATA DE NASCIMENTO
UPDATE EMPREGADO SET 
	IDADE = DATE_PART('year', CURRENT_DATE) - 
			DATE_PART('year', DATA_DE_NASCIMENTO);

--TRIGGER DE UPDATE PARA ATUALIZAR A IDADE DO EMPREGADO
CREATE TRIGGER TRIGGER_ATUALIZA_IDADE
BEFORE UPDATE ON EMPREGADO
FOR EACH ROW
EXECUTE FUNCTION ATUALIZA_IDADE_FN();

--FUNÇÃO PARA ATUALIZAR A IDADE DO EMPREGADO
CREATE OR REPLACE FUNCTION ATUALIZA_IDADE_FN()
RETURNS TRIGGER AS $$
BEGIN
    IF (NEW.DATA_DE_NASCIMENTO <> OLD.DATA_DE_NASCIMENTO) THEN
        NEW.IDADE := DATE_PART('year', AGE(NEW.DATA_DE_NASCIMENTO));
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

--SELECT * FROM EMPREGADO WHERE MATRICULA = 10
UPDATE EMPREGADO SET DATA_DE_NASCIMENTO = '1993-02-04'
WHERE MATRICULA = 10;

--                            ### END 4º QUESTÃO ###

-- ### Desafios com Functions ###

-- 5. Calcular Média Salarial por Departamento:
--    - Crie uma função que retorne a média salarial dos empregados em um 
-- 	determinado departamento. A função deve aceitar o número do departamento 
-- 	como parâmetro.

--DROP FUNCTION MEDIA_SALARIAL_FN
CREATE OR REPLACE FUNCTION MEDIA_SALARIAL_FN(p_num_depto INT)
RETURNS DECIMAL(10,2) AS $$
DECLARE
    MEDIA_SALARIAL DECIMAL(10,2);
BEGIN
    SELECT AVG(SALARIO) INTO MEDIA_SALARIAL
    FROM EMPREGADO
    WHERE NUM_DEPTO = p_num_depto;

    RETURN MEDIA_SALARIAL;
END;
$$ LANGUAGE plpgsql;

SELECT MEDIA_SALARIAL_FN(6);

--                            ### END 5º QUESTÃO ###

-- 6. Promoção em Massa:
--    - Crie uma função que receba um percentual e um número de departamento, e 
-- 	aumente o salário de todos os empregados nesse departamento pelo percentual 
-- 	fornecido.

-- DROP FUNCTION PROMOCAO_EM_MASSA_FN
CREATE OR REPLACE FUNCTION PROMOCAO_EM_MASSA_FN(
    p_num_depto INT, 
    p_percentual INT
)
RETURNS VOID AS $$
BEGIN
    UPDATE EMPREGADO
    SET SALARIO = SALARIO + (SALARIO * (p_percentual / 100))
    WHERE NUM_DEPTO = p_num_depto;
END;
$$ LANGUAGE plpgsql;

--CONSULTANDO A TABELA EMPREGADO PARA VERFICAR OS SALARIOS ANTES DA ATUALIZAÇÃO
SELECT NUM_DEPTO, NOME_EMPREGADO, SALARIO 
FROM EMPREGADO 
WHERE NUM_DEPTO = 1;

--CHAMANDO A FUNÇÃO
CALL PROMOCAO_EM_MASSA_FN(1, 10);

--CONSULTANDO A TABELA EMPREGADO PARA VERFICAR SE OS SALARIOS FORAM ATUALIZADOS
SELECT NUM_DEPTO, NOME_EMPREGADO, SALARIO 
FROM EMPREGADO 
WHERE NUM_DEPTO = 1;

-- OBS:TAMBEM PODEMOS NOTAR QUE A TABELA HISTORICO_SALARIAL SE ATUALIZOU 
-- AUTOMATICAMENTE, POIS O UPDATE DA FUNÇÃO PROMOCAO_EM_MASSA_FN ACIONA 
-- O TRIGGER DA TABELA HISTORICO_SALARIAL 

SELECT * FROM HISTORICO_SALARIAL
	
--                            ### END 6º QUESTÃO ###

-- 7. Função para Listar Empregados por Departamento:
--    - Crie uma função que aceite o nome do departamento como parâmetro e 
-- 	retorne uma lista de todos os empregados que trabalham nesse departamento.

--SELECT * FROM EMPREGADO
CREATE OR REPLACE FUNCTION EMPREGADO_POR_DEPTO_FN(p_nome_depto VARCHAR)
RETURNS TABLE (
    MATRICULA INT,
	NUM_DEPTO INT,
    NOME_EMPREGADO VARCHAR(50),
    SALARIO DECIMAL(10,2)	
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
		e.MATRICULA,
		e.NUM_DEPTO,
		e.NOME_EMPREGADO,
		e.SALARIO
    FROM 
		EMPREGADO e
    JOIN 
		DEPARTAMENTO d ON e.NUM_DEPTO = d.NUM_DEPTO
    		WHERE d.NOME_DEPTO = p_nome_depto;
END;
$$ LANGUAGE plpgsql;

--UTILIZANDO A FUNÇÃOPARA OBTER A LISTA DE EMPREGADOS DO DEPARTAMENTO 'RH'
SELECT * FROM EMPREGADO_POR_DEPTO_FN('RH');

--                            ### END 7º QUESTÃO ###

-- ### Desafios com Views ###

-- 8. Visão de Empregados e Departamentos:
--    - Crie uma view que combine informações da tabela `empregado` e 
-- 	`departamento`, mostrando o nome do empregado, seu salário e o nome do 
-- 	departamento.

--SELECT * FROM VIEW_EMP_DEPTO
CREATE OR REPLACE VIEW VIEW_EMP_DEPTO AS
SELECT
	e.NOME_EMPREGADO AS NOME,
	e.SALARIO AS SALARIO,
	d.NOME_DEPTO
FROM
	EMPREGADO e
JOIN
	DEPARTAMENTO d ON e.NUM_DEPTO = d.NUM_DEPTO

--                            ### END 8º QUESTÃO ###

-- 9. Visão de Empregados por Faixa Salarial:
--    - Crie uma view que categorize empregados em diferentes faixas salariais 
-- 	(por exemplo, abaixo de 2000, entre 2000 e 3000, acima de 3000) e liste os 
-- 	empregados em cada faixa.
	
--SELECT SALARIO FROM EMPREGADO ORDER BY SALARIO DESC
--SELECT * FROM VIEW_FAIXA_SALARIAL
CREATE OR REPLACE VIEW VIEW_FAIXA_SALARIAL AS
SELECT 
    e.MATRICULA,
    e.NOME_EMPREGADO AS NOME,
    e.SALARIO,
    CASE
        WHEN SALARIO < 4900 THEN 'Abaixo de 4900'
        WHEN SALARIO BETWEEN 4900 AND 5300 THEN 'Entre 3900 e 5300'
        ELSE 'Acima de 5300'
    END AS FAIXA_SALARIAL
FROM EMPREGADO e

--                            ### END 9º QUESTÃO ###

-- 10. Visão de Empregados com Aumento Recente:
--     - Crie uma view que mostre todos os empregados que receberam um aumento 
-- 	salarial nos últimos 6 meses, incluindo a data do aumento e o novo salário.
	
--SELECT * FROM HISTORICO_SALARIAL
--SELECT * FROM VIEW_AUMENTO_RECENTE
CREATE OR REPLACE VIEW VIEW_AUMENTO_RECENTE AS
SELECT 
    -- MAT_EMPREGADO,
    -- NOME_EMPREGADO,
    -- SALARIO_ANTIGO,
    -- SALARIO_NOVO,
    -- DATA_HORA
	h.*
FROM 
    HISTORICO_SALARIAL h
WHERE 
    h.DATA_HORA >= CURRENT_DATE - INTERVAL '6 months'

--                            ### END 10º QUESTÃO ###

-- ### Desafios Avançados ###

-- 11. Gerenciamento de Projetos:
--     - Crie tabelas `projeto`, `participacao_projeto` e `empregado`. Crie 
-- triggers e views que gerenciem a alocação de empregados a projetos, registrem 
-- alterações nas participações e permitam visualizar todos os projetos de um 
-- empregado.

--DROP TABLE PARTICIPACAO_PROJETO
CREATE TABLE IF NOT EXISTS PARTICIPACAO_PROJETO (
    ID SERIAL,
    MATRICULA INT NOT NULL,
    NUM_PROJ INT NOT NULL,
    DATA_ALOCACAO TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    DATA_DESALOCACAO TIMESTAMP,
	--CHAVE PRIMARIA
	CONSTRAINT PART_PROJ_ID_PK PRIMARY KEY (ID),
	--CHAVE ESTRANGEIRAS
	CONSTRAINT PART_PROJ_MAT_FK FOREIGN KEY (MATRICULA)
	REFERENCES EMPREGADO (MATRICULA),
	CONSTRAINT PART_PROJ_NUMPROJ_FK FOREIGN KEY (NUM_PROJ)
	REFERENCES PROJETO (NUM_PROJ)
);

CREATE TRIGGER TRIGGER_REGISTRAR_DESALOCACAO
BEFORE UPDATE ON PARTICIPACAO_PROJETO
FOR EACH ROW
WHEN (OLD.DATA_DESALOCACAO IS NULL AND NEW.DATA_DESALOCACAO IS NOT NULL)
EXECUTE FUNCTION T_REGISTRAR_DESALOCACAO();

CREATE OR REPLACE FUNCTION T_REGISTRAR_DESALOCACAO()
RETURNS TRIGGER AS $$
BEGIN
    NEW.DATA_DESALOCACAO := CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE VIEW PROJETOS_POR_EMPREGADO AS
SELECT 
    e.MATRICULA,
    e.NOME_EMPREGADO,
    p.NUM_PROJ,
    p.NOME_PROJETO,
    pp.DATA_ALOCACAO,
    pp.DATA_DESALOCACAO
FROM 
    EMPREGADO e
JOIN 
    PARTICIPACAO_PROJETO pp ON e.MATRICULA = pp.MATRICULA
JOIN 
    PROJETO p ON pp.NUM_PROJ = p.NUM_PROJ;

--SELECT * FROM PARTICIPACAO_PROJETO
INSERT INTO PARTICIPACAO_PROJETO (MATRICULA, NUM_PROJ) VALUES
(1, 1),
(2, 1),
(1, 2);

UPDATE PARTICIPACAO_PROJETO
SET DATA_DESALOCACAO = CURRENT_TIMESTAMP
WHERE MATRICULA = 1;

SELECT * FROM PARTICIPACAO_PROJETO WHERE MATRICULA = 1;

SELECT * FROM PROJETOS_POR_EMPREGADO;
	

--                            ### END 11º QUESTÃO ###

-- 12. Controle de Férias:
--     - Crie uma tabela `ferias` para registrar os períodos de férias dos 
-- empregados. Crie triggers para garantir que as férias não se sobreponham e 
-- functions para calcular o total de dias de férias tirados por cada empregado.

--SELECT * FROM FERIAS
--CRIAÇÃO DA TABELA FERIAS
CREATE TABLE IF NOT EXISTS FERIAS(
    ID SERIAL,
    MATRICULA INT NOT NULL,
    DATA_INICIO DATE NOT NULL,
    DATA_FIM DATE NOT NULL,
	--CHAVE PRIMARIA
    CONSTRAINT FERIAS_ID_PK PRIMARY KEY (ID),
	--CHAVE ESTRANGEIRA
    CONSTRAINT FERIAS_MAT_FK FOREIGN KEY (MATRICULA) 
    REFERENCES EMPREGADO (MATRICULA),
	--CHECK PARA SEMPRE A DATA_FIM SER MAIOR QUE DATA_INICIO
    CONSTRAINT FERIAS_CHECK_DATE CHECK (DATA_FIM > DATA_INICIO)
);

-- TRIGGER PARA VERIFICAR SOBREPOSIÇÃO DE FÉRIAS
CREATE TRIGGER TRIGGER_VERIFICAR_SOBREPOSICAO
BEFORE INSERT OR UPDATE ON FERIAS
FOR EACH ROW
EXECUTE FUNCTION T_VERIFICAR_SOBREPOSICAO_FN();

--FUNÇÃO TRIGGER PARA VERIFICAR SOBREPOSIÇÃO DE FERIAS
CREATE OR REPLACE FUNCTION T_VERIFICAR_SOBREPOSICAO_FN() 
RETURNS TRIGGER AS $$
BEGIN
    IF EXISTS (SELECT 1 FROM FERIAS WHERE MATRICULA = NEW.MATRICULA
        AND (
            (NEW.DATA_INICIO BETWEEN DATA_INICIO AND DATA_FIM)
            OR (NEW.DATA_FIM BETWEEN DATA_INICIO AND DATA_FIM)
            OR (DATA_INICIO BETWEEN NEW.DATA_INICIO AND NEW.DATA_FIM)
            OR (DATA_FIM BETWEEN NEW.DATA_INICIO AND NEW.DATA_FIM)
        	)
    	) THEN
        RAISE EXCEPTION 'O período de férias se sobrepõe, matricula: %', NEW.MATRICULA;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

--FUNÇÃO PARA CALCULAR O TOTAL DE DIAS DE FERIAS
CREATE OR REPLACE FUNCTION TOTAL_FERIAS_FN(p_matricula INT)
RETURNS INT AS $$
DECLARE
    DIAS_TOTAIS INT;
BEGIN
    SELECT COALESCE(SUM(EXTRACT(DAY FROM AGE(DATA_FIM, DATA_INICIO))), 0)
    INTO DIAS_TOTAIS
    FROM FERIAS
    WHERE MATRICULA = p_matricula;

    RETURN DIAS_TOTAIS;
END;
$$ LANGUAGE plpgsql;

--SELECT * FROM FERIAS
--INSERINDO PERÍODOS DE FERIAS
INSERT INTO FERIAS (MATRICULA, DATA_INICIO, DATA_FIM) VALUES 
	(30, '2024-01-01', '2024-01-10');
INSERT INTO FERIAS (MATRICULA, DATA_INICIO, DATA_FIM) VALUES 
	(30, '2024-02-01', '2024-02-15');

--TENTATIVA DE INSERÇÃO DE UM PERIODO DE FERIAS SOBREPOSTO
INSERT INTO FERIAS (MATRICULA, DATA_INICIO, DATA_FIM) VALUES 
	(30, '2024-01-05', '2024-01-15');

--CALCULANDO O TOTAL DE DIAS DE FÉRIAS PARA O EMPREGADO DA MATRICULA 30
SELECT TOTAL_FERIAS_FN(30);

--                            ### END 12º QUESTÃO ###

-- 13. Auditoria de Acessos:
--     - Crie uma tabela `acesso_sistema` que registre cada acesso ao sistema por 
-- empregados. Crie uma função que insira um registro nesta tabela e um trigger 
-- que chame esta função sempre que um empregado se logar no sistema.

--CRIAÇÃO DA TABELA
--SELECT * FROM ACESSO_SISTEMA
CREATE TABLE IF NOT EXISTS ACESSO_SISTEMA(
    ID SERIAL,
    MATRICULA INT NOT NULL,
	NOME_EMPREGADO VARCHAR(100) NOT NULL,
    DATA_HORA TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
	--CHAVE PRIMARIA
	CONSTRAINT ACESSO_SISTEMA_ID_PK PRIMARY KEY (ID),
	--CHAVE ESTRANGEIRA
    CONSTRAINT ACESSO_SISTEMA_MAT_FK FOREIGN KEY(MATRICULA) 
	REFERENCES EMPREGADO(MATRICULA)
);

--CRIAÇÃO DA TABELA LOGIN PARA SIMULAR OS LOGINS DOS EMPREGADOS
--SELECT * FROM LOGIN
CREATE TABLE IF NOT EXISTS LOGIN(
    ID SERIAL,
    MATRICULA INT NOT NULL,
	NOME_EMPREGADO VARCHAR(100) NOT NULL,
    DATA_HORA TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
	--CHAVE PRIMARIA
	CONSTRAINT LOGIN_ID_PK PRIMARY KEY(ID)
);

--CRIAR UM TRIGGER, QUE CHAMA A FUNÇÃO SEMPRE QUE UM EMPREGADO LOGAR NO SISTEMA
CREATE TRIGGER TRIGGER_REGISTRAR_ACESSO
AFTER INSERT ON LOGIN
FOR EACH ROW
EXECUTE FUNCTION T_REGISTRAR_ACESSO_FN();

--FUNÇÃO PARA REGISTRAR O ACESSO NA TABELA ACESSO_SISTEMA
CREATE OR REPLACE FUNCTION REGISTRAR_ACESSO_FN(p_nome_empregado VARCHAR) 
RETURNS VOID AS $$
BEGIN
    IF EXISTS (SELECT 1 FROM EMPREGADO WHERE NOME_EMPREGADO = p_nome_empregado) THEN 
		INSERT INTO ACESSO_SISTEMA (MATRICULA, NOME_EMPREGADO)
	    SELECT 
			MATRICULA, 
			NOME_EMPREGADO 
		FROM 
			EMPREGADO 
			WHERE 
			NOME_EMPREGADO = p_nome_empregado; 
    ELSE
        RAISE EXCEPTION 
			'Empregado não encontrado: %', p_nome_empregado;
    END IF;
END;
$$ LANGUAGE plpgsql;

--FUNÇÃO DE TRIGGER PARA CHAMAR A FUNÇÃO REGISTRAR_ACESSO_FN
CREATE OR REPLACE FUNCTION T_REGISTRAR_ACESSO_FN()
RETURNS TRIGGER AS $$
BEGIN
    PERFORM REGISTRAR_ACESSO_FN(NEW.NOME_EMPREGADO);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

--SELECT MATRICULA, NOME_EMPREGADO FROM EMPREGADO
INSERT INTO LOGIN (MATRICULA, NOME_EMPREGADO) VALUES 
	(24, 'Julia Silva' );

--TESTE COM EMPREGADO INEXISTENTE
INSERT INTO LOGIN (MATRICULA, NOME_EMPREGADO) VALUES 
	(28, 'Julia Silveira' );

--TABELA MOSTRA OS ACESSOS DOS EMPREGADOS ATUALIZADOS
SELECT * FROM ACESSO_SISTEMA

--                            ### END 13º QUESTÃO ###

-- 14. Relatório de Desempenho:
--     - Crie uma view que mostre um relatório de desempenho dos empregados, 
-- combinando informações de tabelas `empregado`, `avaliacao_desempenho` e 
-- `projetos_concluidos`, exibindo a média de avaliações e a quantidade de 
-- projetos concluídos por empregado.

--SELECT * FROM AVALIACAO_DESEMPENHO
--CRIAÇÃO DA TABELA AVALIAÇÃO DE DESEMPENHO
CREATE TABLE IF NOT EXISTS AVALIACAO_DESEMPENHO(
    ID SERIAL,
    MATRICULA INT NOT NULL,
    AVALIACAO DECIMAL(10,2) NOT NULL,
    DATA_AVALIACAO DATE NOT NULL,
	--CHAVE PRIMARIA
    CONSTRAINT AVALIACAO_DESEMPENHO_PK PRIMARY KEY (ID),
	--CHAVE ESTRANGEIRA
    CONSTRAINT AVALIACAO_DESEMPENHO_MAT_FK FOREIGN KEY (MATRICULA) 
    REFERENCES EMPREGADO (MATRICULA)
);

--SELECT * FROM PROJETOS_CONCLUIDOS
--CRIAÇÃO DA TABELA PROJETOS CONCLUIDOS
CREATE TABLE IF NOT EXISTS PROJETOS_CONCLUIDOS (
    ID SERIAL,
    MATRICULA INT NOT NULL,
    NOME_PROJETO VARCHAR(100) NOT NULL,
    DATA_CONCLUSAO DATE NOT NULL,
	--CHAVE PRIMARIA
    CONSTRAINT PROJETOS_CONCLUIDOS_PK PRIMARY KEY (ID),
	--CHAVE ESTRANGEIRA
    CONSTRAINT PROJETOS_CONCLUIDOS_MAT_FK FOREIGN KEY (MATRICULA) 
   	REFERENCES EMPREGADO (MATRICULA)
);

--SELECT * FROM RELATORIO_DESEMPENHO
CREATE OR REPLACE VIEW RELATORIO_DESEMPENHO AS
SELECT 
    e.MATRICULA,
    e.NOME_EMPREGADO,
    COALESCE(AVG(a.AVALIACAO), 0) AS MEDIA_AVALIACOES,
    COUNT(p.ID) AS TOTAL_PROJETOS_CONCLUIDOS
FROM 
    EMPREGADO e
LEFT JOIN 
    AVALIACAO_DESEMPENHO a ON e.MATRICULA = a.MATRICULA
LEFT JOIN 
    PROJETOS_CONCLUIDOS p ON e.MATRICULA = p.MATRICULA
GROUP BY 
    e.MATRICULA, e.NOME_EMPREGADO;
--                            ### END 14º QUESTÃO ###